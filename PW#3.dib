#!meta

{"kernelInfo":{"defaultKernelName":"csharp","items":[{"aliases":[],"languageName":"csharp","name":"csharp"}]}}

#!markdown

# Практическая работа №1. Знакомство с потоками.

**Цель:** Познакомиться с возможностями класса System.Thread платформы .NET Framework.

**Результаты:** После выполнения работы Вы сможете:
1. Запускать длительные операции в отдельном потоке.
2. Завершать поток.
3. Дожидаться завершения выполнения потока. 


**Материалы для самостоятельного изучения**.
1. [Основы управления потоками](https://learn.microsoft.com/en-us/dotnet/standard/threading/managed-threading-basics)
2. [Использование потоков](https://learn.microsoft.com/en-us/dotnet/standard/threading/using-threads-and-threading)
3. [Примитив синхронизации Барьер](https://learn.microsoft.com/ru-ru/dotnet/standard/threading/barrier)
4. [Interlocked операции](https://learn.microsoft.com/en-us/dotnet/api/system.threading.interlocked?view=net-8.0)

## Задание.
Реализовать вычисление определенного интеграла методом трапеции в несколько потоков.

Отрезок, на котором происходит вычисление, разбивается на отрезки по количеству потоков. Для каждого отрезка значение 
интеграла считается в отдельном потоке, после завершения вычисоения полученный рельтаты суммирутся.

**Указание**.
1. Для суммирования результатов удобно воспользоваться разделяемой переменной, к которой будут прибалятся результаты вычисления прямо в самом потоке. Для синхронизации операций сложения лучше всего восользоваться [Interlocked операцией](https://learn.microsoft.com/en-us/dotnet/api/system.threading.interlocked?view=net-8.0).
2. Основная функция долна дождаться завершения всех потоков, которые вычисляют значение на отрезках, прежде чем возвратить результат. Для этого удобнее всего использовать Примитив синхронизации Барьер](https://learn.microsoft.com/ru-ru/dotnet/standard/threading/barrier).

#!csharp

using System;
using System.Threading;


//
// Вычисление определенного интеграла
//
class DefiniteIntegral
{

    // private static object _lockObject = new object();

    //
    // a, b - границы отрезка, на котором происходит вычисление опредленного интеграла
    // function - функция, для которой вычисляется определнный интеграл
    // step - размер одного шага разбиения
    // threadsNumber - число потоков, которые используются для вычислений
    //

    public static double Solve(double a, double b, Func<double, double> function, double step, int threadsnumber)
    {
        double res = 0;
        Barrier barrier = new Barrier(threadsnumber + 1);
        double lengthForThread = (b - a) / (double)threadsnumber;
        
        for(int i = 1; i <= threadsnumber; i++){
            double ai = a + (i-1)*lengthForThread;
            double bi = a + i*lengthForThread;
            Thread thread = new Thread(() => {
                SingleALg(ai , bi, function, step, ref res);
                barrier.SignalAndWait();
            });
            thread.Start();
        }
        barrier.SignalAndWait();
        return res;
    }
    
    static void addDoubleValues(double incrementValue, ref double res) 
    {
        //Можно ли так?
        // lock(_lockObject){
        //     res += incrementValue;
        // }

        double newCurrentValue;
        double currentValue;
        do
        {
            currentValue = res;
            newCurrentValue = currentValue + incrementValue;
        }
        while (Interlocked.CompareExchange(ref res, newCurrentValue, currentValue) != currentValue);
    }


    public static void SingleALg(double a, double b, Func<double, double> function, double step, ref double res){
        int n = (int)((b - a) / step);
        double sum = 0.5 * (function(a) + function(b));

        for (int i = 1; i < n; i++)
        {
            sum += function(a + i * step);
        }

        addDoubleValues(step*sum, ref res);
    }
}

#!csharp

#r "nuget: xunit, 2.8.1"

using Xunit;

var X = (double x) => x;
var SIN = (double x) => Math.Sin(x);

Assert.Equal(0, DefiniteIntegral.Solve(-1, 1, X, 1e-4, 2), 1e-4);

Assert.Equal(0, DefiniteIntegral.Solve(-1, 1, SIN, 1e-5, 8), 1e-4);

Assert.Equal(50, DefiniteIntegral.Solve(0, 10, X, 1e-6, 8), 1e-5);

#!markdown

# Исследование производительности
## Выбор оптимального шага
Необходимо выбрать шаг, который:
- Обеспечивает достаточную для анализа вычислительную нагрузку;
- Даёт точность 1е-4;
- Выполняется в разумное время.
Методом проб и ошибок было определено, что оптимальным является шаг 1е-3.
Нам дал интеграл функции sin(x) на отрезке от -100 до 100. Так как функция симметрична относительно начала координат, а область интегрирования симметрична относительно нуля, то интеграл будет равен нулю. Проверим:

#!csharp

Math.Abs(DefiniteIntegral.Solve(-100, 100, (x) => Math.Sin(x), 1e-3, 1)) < 1e-4

#!markdown

## Исследование производительности многопоточной программы
Проверим время в наносекундах, необходимое для выполнения вычисления интеграла с разным количеством потоков (от 1 до 20). Для каждого количества потоков будет выполняться тридцать замеров и высчитываться средний.

#!csharp

#r "nuget:ScottPlot, 5.0.*"
using System.Diagnostics;

using Microsoft.DotNet.Interactive.Formatting;
Formatter.Register(typeof(ScottPlot.Plot), (p, w) => 
    w.Write(((ScottPlot.Plot)p).GetImageHtml(400, 300)), HtmlFormatter.MimeType);

#!csharp

Stopwatch stopwatch = new Stopwatch();
double[] data = new double[20];
for(int i = 0; i < 20; i++){
    long average = 0;
    for(int j = 1; j <= 30; j++){
        stopwatch.Start();
        DefiniteIntegral.Solve(-100, 100, (x)=>Math.Sin(x), 1e-3, i+1);
        stopwatch.Stop();
        average += stopwatch.ElapsedTicks;
        stopwatch.Reset();
    }
    average /= 30;
    double nanoseconds = (double)average / Stopwatch.Frequency * 1e9;
    // Console.WriteLine($"{i+1} threads: {nanoseconds:F2}");
    data[i] = nanoseconds;
}

double[] t = Enumerable.Range(1, 20).Select(i => (double)i).ToArray();
ScottPlot.Plot plt = new();
plt.Add.Scatter(t, data);
double bestSpeed = data.Min();
double bestThreadNumber = Array.IndexOf(data, bestSpeed);
plt

#!markdown

## Сравнение с однопоточной программой
Сравнение будет проводиться с методом DefiniteIntegral.SingleAlg(...). 

#!csharp

Stopwatch stopwatch = new Stopwatch();
double singleTicks = 0;
for(int j = 1; j <= 30; j++){
    stopwatch.Start();
    DefiniteIntegral.SingleALg(-100, 100, (x)=>Math.Sin(x), 1e-3, ref singleTicks);
    stopwatch.Stop();
    singleTicks += stopwatch.ElapsedTicks;
    stopwatch.Reset();
}
singleTicks /= 30;
double singleThreadSpeed = singleTicks / Stopwatch.Frequency * 1e9;
Console.WriteLine($"Single thread speed: {singleThreadSpeed}");
Console.WriteLine($"{bestThreadNumber}-thread speed: {bestSpeed}");
double precents = ((singleThreadSpeed - bestSpeed) / (singleThreadSpeed / 100));
Console.WriteLine($"{precents:F2}% faster")

#!markdown

## Summary

#!csharp

Console.WriteLine("Выбранный шаг: 1e-3");
Console.WriteLine($"Количество потоков, давшиее максимальную скорость: {bestThreadNumber}");
Console.WriteLine($"Максимальная скорость многопоточной программы (нс): {bestSpeed}");
Console.WriteLine($"Скорость работы однопоточной программы (нс): {singleThreadSpeed}");
Console.WriteLine($"Многопоточная версия быстрее однопоточной на: {precents:F2}%");

#!markdown

### Тестовый прогон
В моём конкретном случае с восьмиядерным процессором цифры получились такие:
```
Выбранный шаг: 1e-3
Количество потоков, давшиее максимальную скорость: 7
Максимальная скорость многопоточной программы (нс): 1100230.4852022128
Скорость работы однопоточной программы (нс): 2713266.604600924
Многопоточная версия быстрее однопоточной на: 59.45%
```
